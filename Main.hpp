#pragma once
#include "Handler.hpp"

uintptr_t data_model;

using namespace types;

uintptr_t rebase(uintptr_t address)
{
	return address - 0x400000 + reinterpret_cast<std::uintptr_t>(GetModuleHandleA(nullptr));
}

// I did NOT make the instance class myself, please credit properly to @n1cholas aka (nicholas) on v3rmillion.

std::vector<std::uintptr_t> GetChildren(const std::uintptr_t instance)
{
	std::vector<std::uintptr_t> children;

	if (!instance)
		return children;

	const auto current = *reinterpret_cast<const std::uintptr_t*>(instance + 0x2C);
	if (!current) return children;

	const auto end = *reinterpret_cast<const std::uintptr_t*>(current + 4u);

	if ((!end) || (end < 0))
	{
		return children;
	}

	for (auto parent = *reinterpret_cast<const std::uintptr_t*>(current); parent < end; parent += 8u)
		children.push_back(*reinterpret_cast<const std::uintptr_t*>(parent));

	return children;
}



std::string getClassName(std::uintptr_t className)
{
	std::string CurrentName;

	DWORD ClassDescriptor = *reinterpret_cast<std::uintptr_t*>(className + 0xC);
	CurrentName = *reinterpret_cast<std::string*>(*reinterpret_cast<std::uintptr_t*>((ClassDescriptor + 0x4)));

	return CurrentName;
}

std::string GetClassType(std::uintptr_t Name)
{
	if (!Name)
		return NULL;

	std::string CurrentName;

	DWORD ClassDescriptor = *reinterpret_cast<std::uintptr_t*>(Name + 0xC);
	CurrentName = *reinterpret_cast<std::string*>(*reinterpret_cast<std::uintptr_t*>((ClassDescriptor + 0x4)));

	return CurrentName;
}

std::uintptr_t FindChildOfClass(DWORD Instance, std::string Class)
{
	if (!Instance)
		return NULL;

	for (std::uintptr_t Child : GetChildren(Instance))
	{
		if (GetClassType(Child) == Class) {
			return Child;
		}
	}
}

// This datamodel is modified from Synapse's X Source code, but working.
uintptr_t GetDataModel()
{
	static DWORD DMPad[16]{};
	r_getdatamodel2(r_gmd2(), DMPad);
	DWORD DM = DMPad[0];
	return DM + offsets::datamodel_ending_vftable;
}

void bypass_console(const char* const title) // Bypass console made by Louka?
{
	DWORD old;
	VirtualProtect(&FreeConsole, 1, PAGE_EXECUTE_READWRITE, &old);
	*reinterpret_cast<uint8_t*>(&FreeConsole) = 0xC3;
	VirtualProtect(&FreeConsole, 1, old, &old);
	AllocConsole();
	SetConsoleTitleA(title);
	FILE* t_dummy = new FILE{};
	freopen_s(&t_dummy, "CONOUT$", "w", stdout);
	freopen_s(&t_dummy, "CONOUT$", "w", stderr);
	freopen_s(&t_dummy, "CONIN$", "r", stdin);
}

int64_t GetUserId(DWORD instance)
{
	return *reinterpret_cast<int64_t*>(instance + 0x70);
}

int GetCreatorId(int Game)
{
	return **(int64_t**)(Game + 0x464) - *(int64_t*)(Game + 0x464);
}

uintptr_t WINAPI Main()
{
	bypass_console("cmd-based haxx");

	auto Game = GetDataModel();
	std::cout << "Initialized DataModel!\n";
	uintptr_t script_context = FindChildOfClass(Game, "ScriptContext");
	uintptr_t workspace = FindChildOfClass(Game, "Workspace");
	std::cout << "Initialized! " << " " << std::endl;
	std::cout << "Initialized! FFlag" << " " << std::endl;
	auto Players = FindChildOfClass(Game, "Players");
	uintptr_t local_player = *reinterpret_cast<uintptr_t*>(Players + offsets::local_player_offset);
	uintptr_t Character = *reinterpret_cast<uintptr_t*>(local_player + offsets::hum_offset);
	uintptr_t Humanoid = FindChildOfClass(Character, "Humanoid");
	uintptr_t backpack = FindChildOfClass(local_player, "Backpack");
	uintptr_t userId = GetUserId(local_player);

	std::string input_handler;
	while (true)
	{
		std::getline(std::cin, input_handler);
		
		if (strcmp(input_handler.c_str(), "speed") == 0)
		{
			types::WalkSpeedSet(Humanoid, 150);
		}

		else if (strcmp(input_handler.c_str(), "age") == 0)
		{
			types::account_age_sent(local_player, 90000000);
		}

		else if (strcmp(input_handler.c_str(), "set_prop") == 0)
		{

		}

		else if (strcmp(input_handler.c_str(), "crash") == 0)
		{
			for (auto i = 0; i < 5000; ++i)
			{
				types::crashServerFunc(backpack);
			}
		}

		else
		{
			std::cout << "Invalid input ! " << " " << std::endl;
		}
	}

}